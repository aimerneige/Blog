# GCC

## GCC 简介

GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写,包含 gcc 、 g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar 、 nm 等。

GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C 、 Pascal 、 Fortran 、 Java 、 Ada 等语言均能进行编译。

GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86 、 ARM 、 PowerPC 、 mips 等，以及 Linux 、 Windows 等软件平台。

GCC 的 C 编译器 是 gcc，其命令格式为 :

```bash
Usage: gcc [options] file...
```

GCC 下默认文扩展名的含义：

| 文件扩展名 | GCC 所理解的含义                    |
| ---------- | ----------------------------------- |
| \*.c       | 该类文件为 C 语言的源文件           |
| \*.h       | 该类文件为 C 语言的头文件           |
| \*.i       | 该类文件为预处理后的 C 文件         |
| \*.C       | 该类文件为 C++ 语言的源文件         |
| \*.cc      | 该类文件为 C++ 语言的源文件         |
| \*.cxx     | 该类文件为 C++ 语言的源文件         |
| \*.m       | 该类文件为 Objective-C 语言的源文件 |
| \*.s       | 该类文件为汇编语言的源文件          |
| \*.o       | 该类文件为汇编后的目标文件          |
| \*.a       | 该类文件为静态库                    |
| \*.so      | 该类文件为共享库                    |
| a.out      | 该类文件为链接后的输出文件          |

GCC 下有很多编译器，可以支持 C 语言，C++语言等多种语言

| GCC 编译器命令 | 含义                 |
| -------------- | -------------------- |
| cc             | 指的是 C 语言编译器  |
| cpp            | 指的是预处理编译器   |
| gcc            | 指的是 C 语言编译器  |
| g++            | 指的是 C++语言编译器 |

## 编译程序的基本知识

GCC 编译器对程序的编译分为 4 个阶段：

1. 预编译
2. 编译和优化
3. 汇编
4. 链接

GCC 的编译器可以将这 4 个步骤合并成一个。

源文件指存放可编辑代码的文件，如存放 C/C++ 和汇编语言的文件。

目标文件是指经过编译器的编译生成的 CPU 可识别的二进制代码，但是目标文件一般不能执行，因为其中的一些函数过程没有相关的指示和说明。

可执行文件就是目标文件与相关的库链接后的文件，它是可以执行的。

预编译过程将程序中引用的头文件包含进源代码中，并对一些宏进行替换。

编译过程将用户可识别的语言翻译成一组处理器可识别的操作码，生成目标文件，通常翻译成汇编语言，而汇编语言通常和机器操作码之间是一种一对一的关系。 GNU 中有 C/C++ 编译器 GCC 和汇编器 as。

所有的目标文件必须用某种方式组合起来才能运行，这就是链接的作用。目标文件中通常仅解析了文件内部的变量和函数，对于引用的函数和变量还没有解析，这需要将其他已经编写好的目标文件引用进来，将没有解析的变量和函数进行解析，通常引用的目标是库。链接完成后会生成可执行文件。

## 单个文件编译成执行文件

下面是一个示例程序的源代码：

```c
// hello.c
#include <stdio.h>

int main()
{
    printf("Hello World!\n");

    return 0;
}
```

将其保存在 `hello.c` 文件中，运行如下命令将代码直接编译成可执行文件：

```bash
$ gcc hello.c
```

上述命令没有指定生成执行文件的名称， GCC 将生成默认的文件名 `a.out`。 运行结果如下：

```bash
$ ./a.out
Hello World!
```

如果希望生成指定的可执行文件名，选项 `-o` 可以使编译程序生成指定文件名，例如将上述程序编译输出一个名称为 `test` 的执行程序：

```bash
$ gcc -o test hello.c
```

上述命令把 `hello.c` 源文件编译成可执行文件 `test`。 运行可执行文件 `test`，向终端输出 `"Hello World!"` 字符串。运行结果如下：

```bash
$ ./test
Hello World!
```

## 编译生成目标文件

GCC 的 `-c` 选项可以用于生成目标文件，这一选项将源文件生成目标文件，而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样，只是扩展名为 `.o`。例如，下面的命令会生成一个名字为 Hello.o 的目标文件：

```bash
$ gcc -c hello.c
```

如果需要生成指定的文件名，可以使用 `-o` 选项。下面的命令将源文件 `hello.c` 编译成目标文件，文件名为 `test.o`：

```bash
$ gcc -c -o test.o hello.c
```

可以用一条命令编译多个源文件，生成目标文件，这通常用于编写库文件或者一个项目中包含多个源文件。例如一个项目包含 `filel.c` 、 `file2.c` 和 `file3.c`, 下面的命令可以将源文件生成 3 个目标文件 : `filel.o` 、 `file2.o` 和 `file3.o`：

```bash
$ gcc -c file1.c file2.c file3.c
```

## 多文件编译

GCC 可以自动链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。例如一个项目包含俩个文件，文件 `string.c` 中有一个函数 `StrLen` 用于计算字符串的长度，而在 `main.c` 中调用这个函数将计算结果显示出来。

### 源文件 `string.c`

```c
// string.c
#define ENDSTRING '\0'
int StrLen(char *string)
{
    int len = 0;

    while (*string++ != ENDSTRING) {
        len++;
    }
    return len;
}
```

### 源文件 `main.c`

```c
// main.c
#include <stdio.h>
extern int StrLen(char *str);
int main()
{
    char src[] = "Hello AimerNeige!\n";
    printf("String length is: %d\n", StrLen(src));

    return 0;
}
```

### 编译运行

下面的命令将俩个源文件中的程序编译成一个执行文件，文件名为 `test`。

```bash
$ gcc -o test strung.c main.c
```

执行编译出来的可执行文件 `test`，程序的运行结果如下：

```bash
$ ./test
String length is: 18
```

当然也可以先将源文件编成目标文件，然后进行链接。例如，下面的过程将 `string.c` 和 `main.c` 源文件编译成目标文件 `string.o` 和 `main.o`，然后将 `string.o` 和 `main.o` 链接生成 `test` ：

```bash
$ gcc -c string.c main.c
$ gcc -o test string.o main.o
```

### 预处理

在 C 语言程序中，通常需要包含头文件并会定义一些宏。 预处理过程将源文件中的头文件包含进源文件中，并且将文件中定义的宏进行扩展。

编译程序时选项 `-E` 告诉编译器进行预编译操作。例如如下命令将文件 `string.c` 的预处理结果显示在计算机屏幕上 :

```bash
$ gcc -E string.c
```

如果需要指定源文件编译后生成的中间结果文件名，需要使用选项 `-o`。例如，下面的代码将文件 `string.c` 进行预编译，生成文件 `string.i`。

```bash
$ gcc -o string.i -E string.c
```

## 编译成汇编语言

生成汇编语言的 GCC 选项 是 `-S`，默认情况下生成的文件名和源文件一致，扩展名为 `.s`。例如，下面的命令将 C 语言源文件 `string.c` 编译成汇编语言，文件名为 `string.s`。

```bash
$ gcc -S string.c
```

## 生成和使用静态链接库

静态库是 `obj` 文件的一个集合，通常静态库以 `.a` 为后缀。静态库由程序 `ar` 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。

静态库的优点是可以在不用重新编译程序库代码的情况下，进行程序的重新链接，这种方法节省了编译过程的时间（在编译大型程序的时候，需要花费很长时间）。但是由于现在系统的强大，编译的时间已经不是问题。静态库的另一个优势是开发者可以提供库文件给使用的人员，不用开放源代码，这是库函数提供者经常采用的手段。当然这也是程序模块化开发的一种手段，使每个软件开发人员的精力集中在自己的部分。在理论上，静态库的执行速度比共享库和动态库要快（1% ～ 5% ）。

### 生成静态链接库

生成静态库，或者将一个 `obj` 文件加到已经存在的静态库的命令为 `ar 库文件 obj文件1 obj文件2`。创建静态库的最基本步骤是生成目标文件，这点前面已经介绍过。然后使用工具 `ar` 对目标文件进行归档。工具 `ar` 的 `-r` 选项，可以创建库，并把目标文件插入到指定库中。例如，将 `string.o` 打包为库文件 `libstr.a` 的命令为：

```bash
$ ar -rcs libstr.a string.o
```

### 使用静态链接库

在编译程序的时候经常需要使用函数库，例如经常使用的 C 标准库等。GCC 链接时使用库函数和一般的 obj 文件的形式是一致的，例如对 main.c 进行链接的时候，需要使用之前已经编译好的静态链接库 libstr.a, 命令格式如下：

```bash
$ gcc -o test main.c libstr.a
```

也可以使用命令 `-l 库名` 进行，库名是不包含函数库和扩展名的字符串。例如编译 `main.c` 链接静态库 `libstr.a` 的命令可以修改为：

```bash
$ gcc -o test main.c -lstr
```

上面的命令将在系统默认的路径下查找 str 函数库，并把它链接到要生成的目标程序上。可能系统会提示无法找到库文件 str , 这是由于 str 库函数没有在系统默认的查找路径下，需要显示指定库函数的路径，例如库文件和当前编译文件在同一目录下：

```bash
$ gcc -o test main.c -L./ -lstr
```

## 生成动态链接库

动态链接库是程序运行时加载的库，当动态链接库正确安装后，所有的程序都可以使用动态库来运行程序。动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址是相对地址，不是绝对地址，其真实地址在调用动态库的程序加载时形成。

动态链接库的名称有别名(soname)、真名(realname)和链接名(linker name)。别名由一个前缀 `lib`，然后是库的名字，再加上一个后缀 `.so` 构成。真名是动态链接库的真实名称，一般总是在别名的基础上加上一个小版本号、发布版本等构成。除此之外，还有一个链接名，即程序链接时使用的库的名字。在动态链接库安装的时候，总是复制库文件到某个目录下，然后用一个软链接生成别名，在库文件进行更新的时候，仅仅更新软链接即可。

### 生成动态链接库

生成动态链接库的命令很简单，使用 `-fPIC` 选项或者 `-fpic`。 `-fPIC` 和 `-fpic` 选项的作用是使得 gcc 生成的代码是位置无关的，例如下面的命令将 `string.c` 编译生成动态链接库：

```bash
$ gcc -shared -Wl,-soname,libstr.so -o libstr.so.1 string.c
```

其中，选项 `-soname,libstr.so` 表示生成动态库时的别名是 `libstr.so`； `-o libstr.so.l` 选项则表示是生成名字为 `libstr.so.1` 的实际动态链接库文件； `-shared` 告诉编译器生成一个动态链接库。

生成动态链接库之后一个很重要的问题就是安装，一般情况下将生成的动态链接库复制到系统默认的动态链接库的搜索路径下，通常有`/lib` 、 `/usr/lib` 、 `/usr/local/lib`，放到以上任何一个目录下都可以。
